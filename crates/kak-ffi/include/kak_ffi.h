#ifndef KAK_FFI_H
#define KAK_FFI_H

/* Auto-generated by cbindgen. Do not edit. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Character category for word motion.
 */
typedef enum CharCategory {
  Blank = 0,
  EndOfLine = 1,
  Word = 2,
  Punctuation = 3,
} CharCategory;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * FNV-1a hash function.
 *
 * Matches Kakoune's `fnv1a` implementation in hash.hh.
 */
uintptr_t fnv1a(const uint8_t *data, uintptr_t len);

/**
 * MurmurHash3 (32-bit) hash function.
 *
 * Matches Kakoune's `murmur3` implementation in hash.cc.
 * Based on <https://github.com/PeterScott/murmur3>
 */
uintptr_t murmur3(const uint8_t *input, uintptr_t len);

/**
 * Combine two hash values.
 *
 * Matches Kakoune's `combine_hash` implementation in hash.hh.
 */
uintptr_t combine_hash(uintptr_t lhs, uintptr_t rhs);

/**
 * Check if codepoint is end-of-line (newline).
 */
bool unicode_is_eol(uint32_t c);

/**
 * Check if codepoint is horizontal blank (whitespace excluding vertical).
 *
 * Characters considered whitespace by ECMA Regex Spec minus vertical tab.
 * <https://262.ecma-international.org/11.0/#sec-white-space>
 */
bool unicode_is_horizontal_blank(uint32_t c);

/**
 * Check if codepoint is blank (whitespace including line terminators).
 *
 * Characters considered Line Terminators by ECMA Regex Spec plus vertical tab.
 * <https://262.ecma-international.org/11.0/#sec-line-terminators>
 */
bool unicode_is_blank(uint32_t c);

/**
 * Check if codepoint is a basic ASCII letter (a-z, A-Z).
 */
bool unicode_is_basic_alpha(uint32_t c);

/**
 * Check if codepoint is a basic ASCII digit (0-9).
 */
bool unicode_is_basic_digit(uint32_t c);

/**
 * Check if codepoint is alphanumeric (ASCII fast path, Unicode fallback).
 *
 * For non-ASCII, uses libc iswalnum.
 */
bool unicode_is_alnum(uint32_t c);

/**
 * Check if codepoint is a word character.
 *
 * Word characters are alphanumeric or underscore.
 * For non-ASCII, defers to libc iswalnum.
 */
bool unicode_is_word(uint32_t c);

/**
 * Check if codepoint is a WORD character (non-blank).
 *
 * In kakoune, WORD means any non-blank character.
 */
bool unicode_is_word_big(uint32_t c);

/**
 * Check if codepoint is punctuation (not word and not blank).
 */
bool unicode_is_punctuation(uint32_t c);

/**
 * Check if codepoint is an identifier character.
 *
 * Identifiers consist of: a-z, A-Z, 0-9, underscore, hyphen.
 */
bool unicode_is_identifier(uint32_t c);

/**
 * Convert ASCII character to lowercase.
 */
uint8_t unicode_to_lower_ascii(uint8_t c);

/**
 * Convert ASCII character to uppercase.
 */
uint8_t unicode_to_upper_ascii(uint8_t c);

/**
 * Check if ASCII character is lowercase.
 */
bool unicode_is_lower_ascii(uint8_t c);

/**
 * Check if ASCII character is uppercase.
 */
bool unicode_is_upper_ascii(uint8_t c);

/**
 * Convert codepoint to lowercase.
 *
 * Uses ASCII fast path, then libc towlower for non-ASCII.
 */
uint32_t unicode_to_lower(uint32_t cp);

/**
 * Convert codepoint to uppercase.
 *
 * Uses ASCII fast path, then libc towupper for non-ASCII.
 */
uint32_t unicode_to_upper(uint32_t cp);

/**
 * Check if codepoint is lowercase.
 *
 * Uses ASCII fast path, then libc iswlower for non-ASCII.
 */
bool unicode_is_lower(uint32_t cp);

/**
 * Check if codepoint is uppercase.
 *
 * Uses ASCII fast path, then libc iswupper for non-ASCII.
 */
bool unicode_is_upper(uint32_t cp);

/**
 * Get display width of a codepoint.
 *
 * Returns 1 for newline, otherwise uses libc wcwidth.
 * Returns 1 for control characters (wcwidth returns -1).
 */
int32_t unicode_codepoint_width(uint32_t c);

/**
 * Categorize a codepoint for word motion.
 */
enum CharCategory unicode_categorize(uint32_t c);

/**
 * Categorize a codepoint for WORD motion (any non-blank is Word).
 */
enum CharCategory unicode_categorize_word(uint32_t c);

/**
 * Check if byte is the start of a UTF-8 character (single or multibyte).
 *
 * Returns true if the byte is not a continuation byte (0b10xxxxxx).
 */
bool utf8_is_character_start(uint8_t byte);

/**
 * Get the number of bytes needed to encode a codepoint in UTF-8.
 *
 * Returns 0 for invalid codepoints (> 0x10FFFF).
 */
uintptr_t utf8_codepoint_size_from_codepoint(uint32_t cp);

/**
 * Get the number of bytes in a UTF-8 character from its first byte.
 *
 * Returns 1 for invalid/continuation bytes.
 */
uintptr_t utf8_codepoint_size_from_byte(uint8_t byte);

/**
 * Decode a UTF-8 sequence to a codepoint.
 *
 * Returns the codepoint and advances `*offset` by the number of bytes consumed.
 * Returns 0xFFFD (replacement char) for invalid sequences.
 * If offset >= len, returns 0xFFFD and does not advance offset.
 */
uint32_t utf8_read_codepoint(const uint8_t *data, uintptr_t len, uintptr_t *offset);

/**
 * Encode a codepoint to UTF-8.
 *
 * Writes to `out` buffer (must have space for at least 4 bytes).
 * Returns the number of bytes written, or 0 for invalid codepoints.
 */
uintptr_t utf8_encode_codepoint(uint32_t cp, uint8_t *out);

/**
 * Count the number of UTF-8 characters in a byte slice.
 *
 * This counts character start bytes only.
 */
uintptr_t utf8_char_count(const uint8_t *data, uintptr_t len);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* KAK_FFI_H */
