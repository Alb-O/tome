//! Action result handler registry.
//!
//! Handlers are registered at compile-time via [`linkme`] distributed slices.
//! The handler slices and [`dispatch_result`] function are generated by
//! `#[derive(DispatchResult)]` on [`ActionResult`].
//!
//! [`ActionResult`]: crate::ActionResult
//! [`dispatch_result`]: crate::dispatch_result

use crate::actions::ActionResult;

/// Outcome of handling an action result.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HandleOutcome {
	/// Result was handled, continue running.
	Handled,
	/// Result was handled, editor should quit.
	Quit,
	/// This handler explicitly declined the result (try next handler in slice).
	NotHandled,
}

/// A handler for a specific ActionResult variant.
pub struct ResultHandler {
	/// Name for debugging/logging.
	pub name: &'static str,
	/// Handle the result, returning the outcome.
	pub handle: fn(&ActionResult, &mut super::EditorContext, bool) -> HandleOutcome,
}

impl std::fmt::Debug for ResultHandler {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("ResultHandler")
			.field("name", &self.name)
			.finish()
	}
}

/// Registers a handler for an [`ActionResult`] variant.
///
/// Handlers are added to the appropriate distributed slice generated by
/// `#[derive(DispatchResult)]` on [`ActionResult`].
///
/// # Example
///
/// ```ignore
/// result_handler!(RESULT_OK_HANDLERS, HANDLE_OK, "ok", |_, _, _| {
///     HandleOutcome::Handled
/// });
/// ```
///
/// [`ActionResult`]: crate::ActionResult
#[macro_export]
macro_rules! result_handler {
	($slice:ident, $static_name:ident, $name:literal, $body:expr) => {
		#[::linkme::distributed_slice($crate::actions::$slice)]
		static $static_name: $crate::editor_ctx::ResultHandler =
			$crate::editor_ctx::ResultHandler {
				name: $name,
				handle: $body,
			};
	};
}
